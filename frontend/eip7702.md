Payments and gas sponsorship
Integrating with EIP-7702
EIP-7702 is an upgrade to EVM blockchains that enables externally owned accounts (EOAs) to set their code to that of a smart contract. In practical terms, this means that EOA wallets will gain AA (account abstraction) capabilities such as transaction bundling, gas sponsorship, and custom permissions.

Privy supports all low level interfaces required by 7702 - signing authorizations and sending type 4 transactions, allowing you to use any implementation of EIP-7702. Use the following guides to get started with EIP-7702 in your application:

​
Signing EIP-7702 authorizations
Privy provides methods to sign EIP-7702 authorizations using the user’s embedded wallet. This authorization is a cryptographic signature that allows an EOA to set its code to that of a smart contract, enabling the EOA to behave like a smart account.

Learn more about signing EIP-7702 authorizations in our dedicated guide.

Learn more about using the signed authorization in the integration guides below!

​
Using EIP-7702 capabilities
Alchemy
Biconomy
Pimlico
ZeroDev
In this guide, we’ll demonstrate how to use Pimlico, a bundler and paymaster service for ERC-4337 accounts, to enable your users to send gasless transactions using EIP-7702 authorization.

Want to see a full end to end example? Check out our starter repo here

​
0. Install dependencies
In your app’s repository, install the required dependencies from Permissionless and Viem:


Copy

Ask AI
npm i @privy-io/wagmi permissionless viem wagmi
​
1. Sign up for a Pimlico account and get your API key
Head to the Pimlico dashboard here and create an account. Generate an API key and create a sponsorship policy for the network you plan to use (optional). Make note of your API key and sponsorship policy ID.

​
2. Configure Privy settings
Configure your app to create embedded wallets for all users.


Copy

Ask AI
<PrivyProvider
  config={{
    embeddedWallets: {
      createOnLogin: 'all-users'
      showWalletUIs: false
    }
  }}
>
  ...
</PrivyProvider>
​
3. Create a simple smart account with Permissionless SDK
Permissionless provides a simple way to create a smart account client that can send user operations with EIP-7702 authorization. All you need is the user’s embedded wallet and the Pimlico API key.


Copy

Ask AI
import {usePrivy, useSign7702Authorization, useWallets} from '@privy-io/react-auth';
import {useSetActiveWallet} from '@privy-io/wagmi';
import {useWalletClient} from 'wagmi';
import {createPublicClient, createWalletClient, http, zeroAddress} from 'viem';
import {sepolia} from 'viem/chains';
import {createSmartAccountClient} from 'permissionless';
import {createPimlicoClient} from 'permissionless/clients/pimlico';
import {entryPoint08Address} from 'viem/account-abstraction';
import {toSimpleSmartAccount} from 'permissionless/accounts';

// Get the Privy embedded wallet
const {wallets} = useWallets();
const {data: walletClient} = useWalletClient();
const embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');

// Set the embedded wallet as active
const {setActiveWallet} = useSetActiveWallet();
useEffect(() => {
  if (embeddedWallet) {
    setActiveWallet(embeddedWallet);
  }
}, [embeddedWallet, setActiveWallet]);

// Create a public client for the chain
const publicClient = createPublicClient({
  chain: sepolia,
  transport: http(process.env.NEXT_PUBLIC_SEPOLIA_RPC_URL)
});

// Create a Pimlico client
const pimlicoApiKey = process.env.NEXT_PUBLIC_PIMLICO_API_KEY;
const pimlicoUrl = `https://api.pimlico.io/v2/sepolia/rpc?apikey=${pimlicoApiKey}`;
const pimlicoClient = createPimlicoClient({
  transport: http(pimlicoUrl)
});

// Create a simple smart account
const simpleSmartAccount = await toSimpleSmartAccount({
  owner: walletClient,
  entryPoint: {
    address: entryPoint08Address,
    version: '0.8'
  },
  client: publicClient,
  address: walletClient.account.address
});

// Create the smart account client
const smartAccountClient = createSmartAccountClient({
  account: simpleSmartAccount,
  chain: sepolia,
  bundlerTransport: http(pimlicoUrl),
  paymaster: pimlicoClient,
  userOperation: {
    estimateFeesPerGas: async () => {
      return (await pimlicoClient.getUserOperationGasPrice()).fast;
    }
  }
});
​
4. Sign the EIP-7702 authorization
Privy provides methods to sign EIP-7702 authorizations using the user’s embedded wallet. This authorization is a cryptographic signature that allows an EOA to set its code to that of a smart contract, enabling the EOA to behave like a smart account.


Copy

Ask AI
// Sign the EIP-7702 authorization
const authorization = await signAuthorization({
  contractAddress: '0xe6Cae83BdE06E4c305530e199D7217f42808555B', // Simple account implementation address
  chainId: sepolia.id,
  nonce: await publicClient.getTransactionCount({
    address: walletClient.account.address
  })
});
​
5. Send a gas-sponsored transaction
With the smart account client configured and the authorization signed, you can now send gasless UserOperations. Below we send an empty call to the zero address:


Copy

Ask AI
const txnHash = await smartAccountClient.sendTransaction({
  calls: [
    {
      to: zeroAddress,
      data: '0x',
      value: BigInt(0)
    }
  ],
  factory: '0x7702',
  factoryData: '0x',
  paymasterContext: {
    sponsorshipPolicyId: process.env.NEXT_PUBLIC_SPONSORSHIP_POLICY_ID
  },
  authorization
});

console.log(`Transaction hash: ${txnHash}`);
console.log(`View on Etherscan: https://sepolia.etherscan.io/tx/${txnHash}`);
​
Conclusion
That’s it! You’ve just executed a gasless transaction from a normal EOA upgraded with EIP-7702 using Pimlico as the bundler and paymaster service.

Explore the rest of the Pimlico docs to learn about advanced features like batching transactions, gas estimation, and more.

Want to see a full end to end example? Check out our starter repo here!


Example code:

"use client"

import { useEffect, useMemo, useState } from "react"

// UI Components
import { Button } from "@/components/ui/button"
import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle
} from "@/components/ui/card"
import { Loader2 } from "lucide-react"

// Privy
import {
    usePrivy,
    useSignAuthorization,
    useSignTypedData,
    useWallets
} from "@privy-io/react-auth"
import { useSetActiveWallet } from "@privy-io/wagmi"

// Blockchain
import { useWalletClient } from "wagmi"
import {
    createPublicClient,
    createWalletClient,
    http,
    zeroAddress
} from "viem"
import { sepolia } from "viem/chains"
import { createSmartAccountClient } from "permissionless"
import { createPimlicoClient } from "permissionless/clients/pimlico"
import { entryPoint08Address } from "viem/account-abstraction"
import { toSimpleSmartAccount } from "permissionless/accounts"

const title = "Privy + Permissionless + 7702"

export function UserOperation() {
    const { user, authenticated, login, logout, ready } = usePrivy()
    const [loading, setLoading] = useState(false)
    const [txHash, setTxHash] = useState<string | null>(null)
    const [error, setError] = useState<string | null>(null)
    const { signAuthorization } = useSignAuthorization()

    const { wallets } = useWallets()
    const { data: walletClient } = useWalletClient()

    const embeddedWallet = useMemo(
        () => wallets.find((wallet) => wallet.walletClientType === "privy"),
        [wallets]
    )

    const { setActiveWallet } = useSetActiveWallet()

    useEffect(() => {
        if (embeddedWallet) {
            setActiveWallet(embeddedWallet)
        }
    }, [embeddedWallet, setActiveWallet])

    const sendUserOperation = async () => {
        if (!user || !user.wallet?.address || !embeddedWallet) {
            setError("No wallet connected")
            return
        }

        setLoading(true)
        setError(null)

        try {
            const pimlicoApiKey = process.env.NEXT_PUBLIC_PIMLICO_API_KEY

            if (!pimlicoApiKey || pimlicoApiKey === "YOUR_PIMLICO_API_KEY") {
                throw new Error(
                    "Please set a valid Pimlico API key in your .env.local file"
                )
            }

            const pimlicoUrl = `https://api.pimlico.io/v2/sepolia/rpc?apikey=${pimlicoApiKey}`

            const publicClient = createPublicClient({
                chain: sepolia,
                transport: http(process.env.NEXT_PUBLIC_SEPOLIA_RPC_URL!)
            })

            const pimlicoClient = createPimlicoClient({
                transport: http(pimlicoUrl)
            })

            // Get the Privy wallet provider
            if (!walletClient) {
                throw new Error("No wallet found")
            }

            const simpleSmartAccount = await toSimpleSmartAccount({
                owner: walletClient,
                entryPoint: {
                    address: entryPoint08Address,
                    version: "0.8"
                },
                client: publicClient,
                address: walletClient.account.address
            })

            // Create the smart account client
            const smartAccountClient = createSmartAccountClient({
                account: simpleSmartAccount,
                chain: sepolia,
                bundlerTransport: http(pimlicoUrl),
                paymaster: pimlicoClient,
                userOperation: {
                    estimateFeesPerGas: async () => {
                        return (await pimlicoClient.getUserOperationGasPrice())
                            .fast
                    }
                }
            })

            const authorization = await signAuthorization({
                contractAddress: "0xe6Cae83BdE06E4c305530e199D7217f42808555B",
                chainId: sepolia.id,
                nonce: await publicClient.getTransactionCount({
                    address: walletClient.account.address
                })
            })

            const txnHash = await smartAccountClient.sendTransaction({
                calls: [
                    {
                        to: zeroAddress,
                        data: "0x",
                        value: BigInt(0)
                    }
                ],
                factory: '0x7702',
                factoryData: '0x',
                paymasterContext: {
                    sponsorshipPolicyId:
                        process.env.NEXT_PUBLIC_SPONSORSHIP_POLICY_ID
                },
                authorization
            })

            setTxHash(txnHash)
        } catch (err) {
            console.error("Error sending user operation:", err)
            setError(err instanceof Error ? err.message : "Unknown error")
        } finally {
            setLoading(false)
        }
    }

    if (!ready) {
        return <div className="p-8 text-center">Loading...</div>
    }

    if (!authenticated) {
        return (
            <div className="p-8 flex flex-col items-center gap-4">
                <h1 className="text-2xl font-bold">{title}</h1>
                <Button onClick={login}>Login with Privy</Button>
            </div>
        )
    }

    return (
        <div className="p-8 flex flex-col items-center gap-4">
            <h1 className="text-2xl font-bold">{title}</h1>

            <Card className="w-[450px]">
                <CardHeader>
                    <CardTitle>Connected Address</CardTitle>
                    <CardDescription className="text-sm font-mono">
                        {embeddedWallet?.address || "No address available"}
                    </CardDescription>
                </CardHeader>
                <CardFooter className="flex gap-2 justify-end">
                    <Button onClick={logout} variant="outline">
                        Logout
                    </Button>
                    <Button
                        onClick={sendUserOperation}
                        disabled={loading}
                        variant="default"
                    >
                        {loading ? (
                            <Loader2 className="h-4 w-4 animate-spin text-amber-500" />
                        ) : null}
                        Send 7702 UserOp
                    </Button>
                </CardFooter>
            </Card>

            {txHash && (
                <Card className="w-full max-w-md bg-green-50 dark:bg-green-950/30 border-green-200 dark:border-green-900">
                    <CardHeader>
                        <CardTitle className="text-base">
                            Transaction Hash
                        </CardTitle>
                        <CardDescription className="break-all font-mono">
                            {txHash}
                        </CardDescription>
                    </CardHeader>
                    <CardFooter>
                        <Button variant="link" className="p-0 h-auto" asChild>
                            <a
                                href={`https://sepolia.etherscan.io/tx/${txHash}`}
                                target="_blank"
                                rel="noopener noreferrer"
                            >
                                View on Etherscan
                            </a>
                        </Button>
                    </CardFooter>
                </Card>
            )}

            {error && (
                <Card className="w-full max-w-md bg-destructive/10 border-destructive/20">
                    <CardHeader>
                        <CardTitle className="text-base">Error</CardTitle>
                        <CardDescription className="break-all text-destructive dark:text-destructive/90">
                            {error}
                        </CardDescription>
                    </CardHeader>
                </Card>
            )}
        </div>
    )
}